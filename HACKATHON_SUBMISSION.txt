                                                     TEAM DETAILS

                                                   Team Name: ORION

                                                    River Labelling Task

Team Members :
1. SRAVYA ISUKAPATLA - Algorithm Developer
2. RAHUL PATRA - Visualization Developer
3. SHUBHAM KUMAR - Integration and Testing Lead

GitHub Repository Link: https://github.com/1651-user/ORION
Demo Link : [Add if available]




1. PROBLEM UNDERSTANDING & SCOPE

1.1 Explain the problem you are solving in your own words.

We are solving the cartographic label placement problem for river geometries. In digital mapping and GIS applications, river polygons need to be labeled with their names in a way that is readable and aesthetically pleasing.

The core challenge involves:

Input: Polygon geometries in WKT (Well-Known Text) format representing river shapes (e.g., the ELBE river with complex, irregular boundaries)

Processing: Finding the optimal position inside each polygon where a text label can be placed

Output: Label placement coordinates (x, y), rotation angle aligned with the river's flow direction, and verification that the label fits within the polygon boundaries

The label must be positioned inside the polygon without overlapping edges, rotated to follow the river's natural flow direction, readable with horizontal or gently angled text preferred, and properly spaced from polygon edges with appropriate padding.






1.2 What assumptions or simplifications did you make to stay within the hackathon scope?

- We work with pre-defined WKT polygon geometries rather than raw GIS/shapefiles
- We use a fixed font aspect ratio (0.6 × font_size) for text width estimation
- Labels are placed individually in each polygon segment
- We don't handle label-to-label collision detection
- The solution focuses on straight text labels rather than curved text





2. SOLUTION APPROACH & DESIGN

2.1 Describe your overall approach to solving the problem.

Our solution uses a multi-strategy algorithm combining three geometric techniques:

STRATEGY 1 - Pole of Inaccessibility (PoI):
Finds the point inside the polygon that is furthest from all edges. This is the "visual center" of the polygon, providing maximum clearance for label placement. Uses an iterative cell-based algorithm inspired by Mapbox's polylabel library. Works correctly for concave and complex polygon shapes unlike simple centroid.

STRATEGY 2 - Oriented Bounding Box (OBB):
Calculates the minimum-area rotated bounding rectangle around the polygon. The angle of this box determines the river's dominant flow direction. This angle becomes the text rotation angle, ensuring labels follow the river.

STRATEGY 3 - Negative Buffer Padding:
Applies an inward buffer to the polygon (shrinks it). Ensures labels are placed with proper spacing from edges. Handles edge cases where buffering makes the polygon invalid.



Algorithm Workflow:
Load WKT File → Parse Polygons → Apply Padding → Find PoI (Center) → Calculate Flow Direction → Validate Fit Check → Generate SVG + PNG Visualizations



2.2 Why did you choose this approach?

Alternatives Considered:

Centroid-based placement: We didn't use this because centroids can fall outside concave/C-shaped polygons.

Skeleton/Medial Axis: We didn't use this because it's more computationally expensive for similar results.

Grid-based sampling: We didn't use this because it's less precise than PoI for irregular shapes.

Random placement: We didn't use this because there's no guarantee of optimal positioning.

Trade-offs Made:
- Chose computational precision over speed (PoI is iterative but accurate)
- Prioritized individual polygon labeling over global optimization (simpler, more reliable)
- Used approximate text metrics for faster development

The Pole of Inaccessibility approach is specifically designed for cartography and is used by major mapping platforms. It guarantees the label center is as far from edges as possible—critical for readability.




3. TECHNICAL IMPLEMENTATION

3.1 Describe the technical implementation of your solution.

Technologies and Libraries Used:

- Shapely 2.0+ for geometry processing (WKT parsing, buffering, spatial operations)
- Matplotlib 3.7+ for PNG visualization
- svgwrite 1.4+ for SVG vector graphics output
- Pillow 10.0+ for text metrics estimation
- NumPy 1.24+ for coordinate calculations
- Python 3.x as the core language

Project Structure:

- river_labeler.py: Core algorithm (PoI, OBB, placement logic)
- visualizer.py: SVG/PNG rendering with annotations
- demo.py: End-to-end demonstration script
- river.wkt: Sample ELBE river polygon data (3 segments)
- requirements.txt: Python dependencies
- output/: Generated visualizations (river_labels.svg, river_labels.png, polygon images)

Key Classes and Functions:

- LabelPlacement (dataclass): Stores x, y, rotation, fits_inside, available dimensions
- pole_of_inaccessibility(): Finds the point furthest from all polygon edges
- get_oriented_bounding_box(): Calculates minimum-area rotated bounding box
- calculate_flow_direction(): Determines river direction (normalized 0-180°)
- RiverLabeler (class): Main interface for label placement
- RiverVisualizer (class): Generates SVG and PNG outputs

3.2 What were the main technical challenges and how did you overcome them?

Challenge 1 - Handling Concave/Complex River Polygons:
Problem: Simple centroids fall outside C-shaped or concave polygons.
Solution: Implemented Pole of Inaccessibility algorithm with fallback to representative_point() when centroid is outside polygon.

Challenge 2 - Determining Readable Text Rotation:
Problem: Raw rotation angles can result in upside-down or hard-to-read text.
Solution: Normalized angles to 0-180° range, preferring angles closer to horizontal.

Challenge 3 - Ensuring Text Fits Inside Irregular Shapes:
Problem: The "maximum inscribed circle" doesn't directly give rectangle dimensions.
Solution: Applied negative buffer for padding, then calculated effective dimensions accounting for rotation using trigonometry.

Challenge 4 - Empty Polygons After Buffering:
Problem: Small polygons can disappear when negative buffer is applied.
Solution: Implemented graceful fallback: try half padding, then no padding if needed.




4. RESULTS & EFFECTIVENESS

4.1 What does your solution successfully achieve?

Requirements Met:
- Correctly places labels inside all 3 test river polygons
- Calculates optimal rotation following river flow direction
- Verifies whether text fits with proper padding
- Generates publication-quality SVG and PNG outputs
- Handles both elongated (horizontal) and curved river segments
- Provides detailed placement information (coordinates, angles, fit status)

Sample Output Results:

Polygon 1: Position (11761, 24546), Rotation 86.3°, Fits Inside: Yes
Polygon 2: Position (11331, 25199), Rotation -7.9°, Fits Inside: Yes
Polygon 3: Position (11757, 24986), Rotation -65.2°, Fits Inside: Yes


4.2 How did you validate or test your solution?

Validation Methods:

1. Visual Verification: Generated PNG/SVG outputs show labels correctly positioned inside each polygon. Red dots mark exact placement points for verification. Annotations show coordinates and rotation angles.

2. Automatic Fit Verification: Algorithm reports fits_inside = True/False for each placement. All 3 test polygons report successful fit.

3. Edge Case Testing: Tested with horizontal river segment (Polygon 2), nearly vertical segment (Polygon 1), and curved/diagonal segment (Polygon 3).

4. Boundary Checking: Visual inspection confirms labels don't overlap polygon edges. Padding buffer ensures minimum clearance from boundaries.









5. INNOVATION & PRACTICAL VALUE

5.1 What is innovative or unique about your solution?

1. Cartographically-Correct Algorithm: Uses the Pole of Inaccessibility, a well-known technique in professional cartography used by Mapbox and other major mapping platforms. Rarely implemented in hackathon projects due to complexity.

2. Rotation-Aware Fitting: Accounts for label dimensions when rotated using trigonometric calculations. Ensures proper fit regardless of text angle.

3. Multi-Output Visualization: Generates both vector (SVG) and raster (PNG) formats. Includes debug annotations (coordinates, angles, center points). Produces both combined and individual polygon views.

4. Modular, Reusable Design: Clean separation between algorithm (river_labeler.py) and visualization (visualizer.py). Easy to integrate into larger GIS pipelines.


5.2 How can this solution be useful in a real-world or production scenario?

Real-World Applications:

- Digital Mapping Platforms: Google Maps, Mapbox, OpenStreetMap for automatic river labeling
- GIS Software Integration: QGIS, ArcGIS plugin for automated label placement
- Print Cartography: Automated map production for atlases and publications
- Navigation Applications: Mobile apps displaying water feature names
- Government/Environmental Agencies: Flood mapping and water resource management

Scalability: Can process thousands of river polygons in batch mode. Algorithm complexity is O(n log n) for PoI calculation.




6. LIMITATIONS & FUTURE IMPROVEMENTS

6.1 What are the current limitations of your solution?

- No Label Collision Detection: Multiple labels in close proximity may overlap
- Straight Text Only: Labels don't curve along the river path
- Approximate Text Metrics: Uses estimated character width rather than actual font rendering
- Single Label Per Polygon: Large polygons get only one label
- No Priority/Ranking System: All polygons get labels regardless of size


6.2 If you had more time, what improvements or extensions would you make?

- Curved Text Rendering: Render labels along the river centerline using Bézier curves
- Label Collision Detection: Detect and resolve overlapping labels with priority-based omission
- Real Font Metrics: Load actual TTF/OTF font files for precise text bounding box calculation
- Multi-Scale Labeling: Different label strategies based on zoom level
- Label Repetition: For long rivers, place multiple labels at intervals
- Interactive Web Demo: Web-based interface to upload WKT and visualize results
- Support for More Formats: GeoJSON and Shapefile input support



FINAL DECLARATION

We confirm that this submission is our own work and was developed during the hackathon period.

Team Representative Name: SRAVYA ISUKAPATLA
Confirmation: Yes



